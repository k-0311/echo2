# 基础数据类型

```rust
字符类型 char
所有整数类型，例如 i32 、 u32 、 i64 等
所有浮点类型，f32 和 f64
布尔类型 bool，值为 true 或 false
仅包含以上类型数据的元组（Tuples）//上述几种基本类型的集合
let tup = ("ubi", 996, 3.14, false);
let (a,b,c,d) = tup;
//与JS相似，基础类型可分为 number、str、boolean 三种，其中number类型包含整数和浮点数
//同样具有堆、栈概念，基础类型存在栈中，引用类型也是以指针的形式指向内存地址
//字符串分两种类型，一种是存于栈上的(char)，即被硬编码进程序里的字符串值，大小已知不可变的
//另一种是 String，这个类型被分配到堆上，所以能够存储在编译时未知大小的文本

//与JS引用类型的不同点，当 s1 赋值给 s2 以后 s1 将不可以再被使用
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world!", s1); // 错误！s1 已经失效

//所有权与函数
let x1 = String::from("someone");
let x2 = 5;
//跟赋值语句一样，引用类型作为参数传入函数时所有权将改变
//基础类型则复制一份
some_fn1(x1);// x1 进入函数作用域，此时外部作用域 x1 失效
some_fn2(x2);// x2 是基础类型，会复制一份传入函数，因此外部作用域还能继续使用

//引用与借用
let x3 = String::from("sth");
let x4 = String::from("sth");
//使用 &x3 符号可以创建一个指向 x3 的引用，但是并不拥有它。
//因为并不拥有这个值，当 '引用' 离开作用域时其指向的值也不会被丢弃
some_fn3(&x3,&x4);
//同样，函数也使用 & 符号来标识 '引用' 的参数
//我们将获取 '引用' 作为函数参数称为 '借用'
fn some_fn3(x3:&mut String,x4:&String){
  x3.push_str("xxx")// x3是可变引用，因此可以修改，但是同一个值在同一个作用域内只能拥有一个可变引用
  x4.push_str("xxx")//错误！借用的值不可修改
}

```
